class converter(int):  # Это было сложно и долго;) Но, вроде, все работает! Создали класс c наследованием от int
    def Rim_to_Arab(self,y):  # Создали функцию 1
        R = {"I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000}  # Сделали снова словарик!
        # Я хотел учесть Ваше замечание про константный словарик в функции,
        # Но если его вынести за пределы функции, то python почему-то не видит его при выполнении!
        # Поэтому пришлось оставлять! Но он же работает!
        n = 0
        for i in range(len(y) - 1):
            if R[y[i]] < R[y[i+1]]:  # Если предыдущий знак меньше следующего
                n = n - R[y[i]]  # То берем его со знаком -
            else:
                n = n + R[y[i]]  # Все остальные просто плюсуем, не забыв поставить соответствие
        n = n + R[y[len(y) - 1]]  # Для последнего приходится отдельно, чтоб не вылезти за рамки
        return n

    def Arab_to_Rim(self, y):  # Вот и функция 2
        I = (1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000)  # Другого способа не нашел! Хотя очень так не хотелось! Тогда и первую можно было через 2 списка решать
        R = ('I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M')  # здесь еще надо указать все числа типа 4, 9, 40, иначе он неправильно их будет писать
        n = ''  # тепрь число будем записывать в список
        if y != 0:  # Не забываем, что нуля нет!
            for i in range(13):  # 13 так как в списке I 13 элементов получилось, можно было больше!
                n = n + y // I[12 - i] * R[12 - i]  # первую цифру и пишем столько раз, сколько соответствующих разрядов
                y = y % I[12 - i]  # уменьшаем число до следующего разряда
        else:
            n = "The number zero does not have its own Roman numeral"
        return n


y = input("Input the Roman numeral and I will convert it to arabic number! ")
print(converter().Rim_to_Arab(y))
x = int(input("Input the arabic number and I will convert it to Roman numeral! "))
print(converter().Arab_to_Rim(x))
